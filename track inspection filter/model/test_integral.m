

% =========================================================================
%
%                  测试
%
% =========================================================================
%
%　(C)2019-2022 铁道科学研究院-基础所
%   版本：V1.0
%   日期：2020年 9月16日
%   作者：s.m.
%--------------------------------------------------------------------------
%  功能： 1.差分的计算与结果对比
%        2.
%        3. 
%  进一步想法：
%           1.可以通过仿真的方法，对比分析误差量
%           2.怎么样去仿真呢？这是一个问题，是不是可以进行模态分析？
% 
% 10.14
%   1. 讨论二阶差分与积分直接的关系；积分实际上也是一种低通滤波的形式
%   2. 讨论IMU数据的处理
% 
%--------------------------------------------------------------------------

%%
% d = textread('gplpe.txt');
% for i = 1:length(d)
%     if i == 1
%        x_dot = 0;
%        x_dot_2 = 0;
%        p_x_dot = 0;
%     else
%         x_dot = d(i) - d(i-1);
%         x_dot_2 = x_dot - p_x_dot;
%         p_x_dot = x_dot;
%         
%         x_dot_2_s(i) = x_dot_2;
%     end
% end
% 
% x_dot = 0;
% p_x_dot = 0;
% x = 0;
% p_x = 0;
% for i = 4:length(d)
%     
%     x_dot_2 = x_dot_2_s(i);
%     x_dot = x_dot + x_dot_2;
%     x = x + x_dot;
% 
%     
%     x_s(i) = x;
%     
% end
% 
% figure;
% plot([zeros(1,0), x_s]);
% hold on;
% plot(d)



%% 为什么用二阶差分的方法
clear all;
close all;
del_t = 1/256;
fs = 1/del_t;
t = 0:del_t:5;
T = 10; 
a = -25*sin( 5*t );
% a = 2*ones(1,length(t));
% a = 20*t.^3;
% a = 9 * exp(3*t);
v = 5;
s = 0;
s_dot = 0.039062/2;
for i = 1:length(t)
   tmp = a(i) * del_t * del_t;
   s_dot(i+1) = s_dot(i) + tmp;
   s(i+1) = s(i) + s_dot(i);
%    v(i+1) = v(i) + a(i)*del_t;
%    s(i+1) = s(i) + v(i)*del_t;
end
% figure;plot(s(1:end-1) - sin(5*t));
figure;plot(t , s(1:end-1));
hold on;
plot(t, sin(5*t));

figure;plot(sin(5*t)-s(1:end-1));

%% 结论
%{
差分求和的方法适用多项式函数、指数函数，正余弦函数，唯一需要注意的就是，一阶差分需要
在一个正确的值附近，不然二阶求和就会产生漂移。
那么怎么分析？
%}

%% 对比IMU数据的两种积分方法的问题












